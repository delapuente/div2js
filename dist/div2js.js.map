{
  "version": 3,
  "sources": [
    "div2lang.js",
    "symbols.js",
    "ast.js",
    "templates.js",
    "context.js",
    "div2trans.js",
    "div2js.js"
  ],
  "names": [],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "div2js.js",
  "sourcesContent": [
    "\n\ndefine('div2lang',['require'],function(require){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,7],$V1=[1,9],$V2=[5,37],$V3=[9,23,60,61,69,72,73,81,83,97,98,100,104,105,107,108,109,112,113,116,117,119,120,121,122,124,125,127,129,131,135,136,137,138,139,140,141,142,143,144],$V4=[18,20,21,38],$V5=[1,18],$V6=[2,12],$V7=[20,21,38],$V8=[15,18,20,21,38],$V9=[1,23],$Va=[2,16],$Vb=[21,38],$Vc=[20,21,27,28,29,30,31,32,33,34,35,38],$Vd=[1,31],$Ve=[1,44],$Vf=[1,46],$Vg=[1,47],$Vh=[1,48],$Vi=[1,79],$Vj=[1,49],$Vk=[1,50],$Vl=[1,51],$Vm=[1,52],$Vn=[1,53],$Vo=[1,54],$Vp=[1,55],$Vq=[1,56],$Vr=[1,57],$Vs=[1,77],$Vt=[1,78],$Vu=[1,68],$Vv=[1,69],$Vw=[1,70],$Vx=[1,71],$Vy=[1,72],$Vz=[1,73],$VA=[1,74],$VB=[1,87],$VC=[1,88],$VD=[1,89],$VE=[1,90],$VF=[1,91],$VG=[1,92],$VH=[1,93],$VI=[1,94],$VJ=[1,95],$VK=[5,15,37,40,43,56,57,58,59,60,62,67,70,74,75,78,79,80,84,90,91,92,94,95,104,105,106,107,108,109,110],$VL=[1,99],$VM=[15,40,43,56,57,58,59,60,62,74,75,78,79,80,84,90,91,92,94,95,104,105,106,107,108,109,110],$VN=[1,115],$VO=[9,61,69,72,73,81,83,98],$VP=[9,61,69,72,73,81,83,98,107,108,109,112,113,116,117,119,120,121,122,124,125,127,129,131],$VQ=[2,115],$VR=[9,23,61,69,72,73,81,83,98,107,108,109,112,113,116,117,119,120,121,122,124,125,127,129,131,135,136,137,138,139,140,141,142,143,144],$VS=[9,61,69,72,73,81,83,98,131],$VT=[1,142],$VU=[9,15,23,60,61,69,72,73,81,83,94,95,97,98,100,104,105,106,107,108,109,110,112,113,116,117,119,120,121,122,124,125,127,129,131,135,136,137,138,139,140,141,142,143,144],$VV=[15,60,94,95,104,105,106,107,108,109,110],$VW=[9,61,69,72,73,81,83,98,129,131],$VX=[1,143],$VY=[9,61,69,72,73,81,83,98,127,129,131],$VZ=[1,145],$V_=[1,146],$V$=[9,61,69,72,73,81,83,98,124,125,127,129,131],$V01=[1,147],$V11=[1,148],$V21=[1,149],$V31=[1,150],$V41=[9,61,69,72,73,81,83,98,119,120,121,122,124,125,127,129,131],$V51=[1,151],$V61=[1,152],$V71=[9,61,69,72,73,81,83,98,116,117,119,120,121,122,124,125,127,129,131],$V81=[1,153],$V91=[1,154],$Va1=[9,61,69,72,73,81,83,98,108,109,116,117,119,120,121,122,124,125,127,129,131],$Vb1=[1,155],$Vc1=[1,156],$Vd1=[1,157],$Ve1=[9,15,40,43,56,57,58,59,60,62,74,75,78,79,80,84,90,91,92,94,95,104,105,106,107,108,109,110],$Vf1=[9,15,60,94,95,104,105,106,107,108,109,110],$Vg1=[1,209],$Vh1=[9,61,72],$Vi1=[1,225],$Vj1=[1,223],$Vk1=[15,60,61,94,95,104,105,106,107,108,109,110],$Vl1=[15,40,56,57,58,59,60,62,74,75,79,80,84,90,91,92,94,95,104,105,106,107,108,109,110],$Vm1=[40,67,70],$Vn1=[69,72];\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"translation_unit\":3,\"program\":4,\"EOF\":5,\"process_list\":6,\"PROGRAM\":7,\"id\":8,\";\":9,\"const_block\":10,\"global_block\":11,\"local_block\":12,\"private_block\":13,\"body\":14,\"NAME\":15,\"CONST\":16,\"const_declaration_list\":17,\"GLOBAL\":18,\"declaration_list\":19,\"LOCAL\":20,\"PRIVATE\":21,\"const_declaration\":22,\"=\":23,\"expression\":24,\"declaration\":25,\"type\":26,\"INT_POINTER\":27,\"INT\":28,\"WORD_POINTER\":29,\"WORD\":30,\"BYTE_POINTER\":31,\"BYTE\":32,\"STRING_POINTER\":33,\"STRING\":34,\"STRUCT_POINTER\":35,\"process\":36,\"PROCESS\":37,\"BEGIN\":38,\"group_of_sentences\":39,\"END\":40,\"sentence_list\":41,\"group_of_sentences_for_if_else\":42,\"ELSE\":43,\"sentence\":44,\"if_sentence\":45,\"switch_sentence\":46,\"while_sentence\":47,\"repeat_sentence\":48,\"opt_end\":49,\"loop_sentence\":50,\"from_sentence\":51,\"for_sentence\":52,\"return_sentence\":53,\"frame_sentence\":54,\"clone_sentence\":55,\"DEBUG\":56,\"BREAK\":57,\"CONTINUE\":58,\"IF\":59,\"(\":60,\")\":61,\"SWITCH\":62,\"group_of_cases\":63,\"default\":64,\"case_list\":65,\"case\":66,\"CASE\":67,\"list_of_ranges\":68,\":\":69,\"DEFAULT\":70,\"range\":71,\",\":72,\"..\":73,\"WHILE\":74,\"REPEAT\":75,\"group_of_sentences_for_repeat\":76,\"until_condition\":77,\"UNTIL\":78,\"LOOP\":79,\"FROM\":80,\"TO\":81,\"step\":82,\"STEP\":83,\"FOR\":84,\"for_params\":85,\"initialization\":86,\"condition\":87,\"increment\":88,\"expression_list\":89,\"RETURN\":90,\"FRAME\":91,\"CLONE\":92,\"primary_expression\":93,\"STRING_LITERAL\":94,\"NUMBER\":95,\"postfix_expression\":96,\"[\":97,\"]\":98,\"call_expression\":99,\".\":100,\"update_operator\":101,\"unary_expression\":102,\"unary_operator\":103,\"++\":104,\"--\":105,\"&\":106,\"*\":107,\"+\":108,\"-\":109,\"!\":110,\"multiplicative_expression\":111,\"/\":112,\"%\":113,\"additive_expression\":114,\"shift_expression\":115,\"<<\":116,\">>\":117,\"relational_expression\":118,\"<\":119,\">\":120,\"<=\":121,\">=\":122,\"equality_expression\":123,\"==\":124,\"!=\":125,\"and_expression\":126,\"&&\":127,\"exclusive_or_expression\":128,\"^\":129,\"inclusive_or_expression\":130,\"||\":131,\"conditional_expression\":132,\"assignment_expression\":133,\"assignment_operator\":134,\"*=\":135,\"/=\":136,\"%=\":137,\"+=\":138,\"-=\":139,\"<<=\":140,\">>=\":141,\"&=\":142,\"^=\":143,\"|=\":144,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",7:\"PROGRAM\",9:\";\",15:\"NAME\",16:\"CONST\",18:\"GLOBAL\",20:\"LOCAL\",21:\"PRIVATE\",23:\"=\",27:\"INT_POINTER\",28:\"INT\",29:\"WORD_POINTER\",30:\"WORD\",31:\"BYTE_POINTER\",32:\"BYTE\",33:\"STRING_POINTER\",34:\"STRING\",35:\"STRUCT_POINTER\",37:\"PROCESS\",38:\"BEGIN\",40:\"END\",43:\"ELSE\",56:\"DEBUG\",57:\"BREAK\",58:\"CONTINUE\",59:\"IF\",60:\"(\",61:\")\",62:\"SWITCH\",67:\"CASE\",69:\":\",70:\"DEFAULT\",72:\",\",73:\"..\",74:\"WHILE\",75:\"REPEAT\",78:\"UNTIL\",79:\"LOOP\",80:\"FROM\",81:\"TO\",83:\"STEP\",84:\"FOR\",90:\"RETURN\",91:\"FRAME\",92:\"CLONE\",94:\"STRING_LITERAL\",95:\"NUMBER\",97:\"[\",98:\"]\",100:\".\",104:\"++\",105:\"--\",106:\"&\",107:\"*\",108:\"+\",109:\"-\",110:\"!\",112:\"/\",113:\"%\",116:\"<<\",117:\">>\",119:\"<\",120:\">\",121:\"<=\",122:\">=\",124:\"==\",125:\"!=\",127:\"&&\",129:\"^\",131:\"||\",135:\"*=\",136:\"/=\",137:\"%=\",138:\"+=\",139:\"-=\",140:\"<<=\",141:\">>=\",142:\"&=\",143:\"^=\",144:\"|=\"},\nproductions_: [0,[3,2],[3,3],[4,8],[8,1],[10,2],[10,0],[11,2],[11,0],[12,2],[12,0],[13,2],[13,0],[17,0],[17,2],[22,4],[19,0],[19,2],[25,5],[25,3],[26,1],[26,1],[26,1],[26,1],[26,1],[26,1],[26,1],[26,1],[26,1],[6,1],[6,2],[36,5],[14,2],[39,1],[39,2],[42,1],[42,2],[44,1],[44,1],[44,1],[44,2],[44,1],[44,1],[44,1],[44,2],[44,2],[44,1],[44,2],[44,2],[44,2],[44,2],[49,0],[49,1],[45,5],[45,6],[46,5],[41,1],[41,2],[63,1],[63,2],[63,2],[63,3],[65,1],[65,2],[66,4],[64,3],[68,1],[68,3],[71,1],[71,3],[47,5],[48,2],[76,1],[76,2],[77,4],[50,2],[51,9],[82,0],[82,2],[52,3],[85,4],[86,1],[86,2],[87,1],[87,2],[88,1],[88,2],[53,1],[53,4],[54,1],[54,4],[55,2],[89,1],[89,3],[93,1],[93,1],[93,1],[93,3],[96,1],[96,4],[96,1],[96,3],[96,2],[99,3],[99,4],[102,1],[102,2],[102,2],[101,1],[101,1],[103,1],[103,1],[103,1],[103,1],[103,1],[111,1],[111,3],[111,3],[111,3],[114,1],[114,3],[114,3],[115,1],[115,3],[115,3],[118,1],[118,3],[118,3],[118,3],[118,3],[123,1],[123,3],[123,3],[126,1],[126,3],[128,1],[128,3],[130,1],[130,3],[132,1],[133,1],[133,3],[134,1],[134,1],[134,1],[134,1],[134,1],[134,1],[134,1],[134,1],[134,1],[134,1],[134,1],[24,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\n \n      this.$ = {\n        type: \"Unit\",\n        program: $$[$0-1],\n        processes: []\n      };\n      return this.$;\n    \nbreak;\ncase 2:\n\n      this.$ = {\n        type: \"Unit\",\n        program: $$[$0-2],\n        processes: $$[$0-1]\n      };\n      return this.$;\n    \nbreak;\ncase 3:\n\n      this.$ = {\n        type: \"Program\",\n        name: $$[$0-6],\n        consts: $$[$0-4],\n        globals: $$[$0-3],\n        locals: $$[$0-2],\n        privates: $$[$0-1],\n        body: $$[$0]\n      };\n    \nbreak;\ncase 4:\n this.$ = { type: \"Identifier\", name: $$[$0] }; \nbreak;\ncase 5:\n\n      this.$ = {\n        type: \"ConstDeclarations\",\n        declarations: $$[$0]\n      };\n    \nbreak;\ncase 6: case 8: case 10: case 12:\n this.$ = null; \nbreak;\ncase 7:\n\n      this.$ = {\n        type: \"GlobalDeclarations\",\n        declarations: $$[$0]\n      };\n    \nbreak;\ncase 9:\n\n      this.$ = {\n        type: \"LocalDeclarations\",\n        declarations: $$[$0]\n      };\n    \nbreak;\ncase 11:\n\n      this.$ = {\n        type: \"PrivateDeclarations\",\n        declarations: $$[$0]\n      };\n    \nbreak;\ncase 13: case 16: case 33: case 35: case 58: case 81: case 83: case 85:\n this.$ = []; \nbreak;\ncase 14: case 17:\n this.$ = $$[$0-1].concat([$$[$0]]); \nbreak;\ncase 15:\n\n      // TODO: I think consts are actually MACROS\n      this.$ = {\n        type: \"ConstDeclarator\",\n        constType: \"int\",\n        constName: $$[$0-3],\n        constInit: $$[$0-1]\n      };\n    \nbreak;\ncase 18:\n\n      this.$ = {\n        type: \"VariableDeclarator\",\n        varType: $$[$0-4],\n        varName: $$[$0-3],\n        varInit: $$[$0-1]\n      };\n    \nbreak;\ncase 19:\n\n      this.$ = {\n        type: \"VariableDeclarator\",\n        varType: $$[$0-2],\n        varName: $$[$0-1],\n        varInit: null\n      };\n    \nbreak;\ncase 20:\n this.$ = \"int_pointer\"; \nbreak;\ncase 21:\n this.$ = \"int\"; \nbreak;\ncase 22:\n this.$ = \"word_pointer\"; \nbreak;\ncase 23:\n this.$ = \"word\"; \nbreak;\ncase 24:\n this.$ = \"byte_pointer\"; \nbreak;\ncase 25:\n this.$ = \"byte\"; \nbreak;\ncase 26:\n this.$ = \"string_pointer\"; \nbreak;\ncase 27:\n this.$ = \"string\"; \nbreak;\ncase 28:\n this.$ = \"struct_pointer\"; \nbreak;\ncase 29:\n\n      this.$ = [$$[$0]];\n    \nbreak;\ncase 30:\n\n      this.$ = $$[$0-1].push($$[$0]);\n    \nbreak;\ncase 31:\n\n      this.$ = {\n        type: \"Process\",\n        name: $$[$0-3],\n        privates: $$[$0-1],\n        body: $$[$0]\n      };\n    \nbreak;\ncase 32:\n\n      this.$ = {\n        type: \"ProcessBody\",\n        sentences: $$[$0]\n      };\n    \nbreak;\ncase 34: case 36: case 74: case 97:\n this.$ = $$[$0-1]; \nbreak;\ncase 47:\n this.$ = { type: \"DebugSentence\" }; \nbreak;\ncase 48:\n\n      this.$ = {\n        type: \"ExpressionSentence\",\n        expression: $$[$0-1]\n      };\n    \nbreak;\ncase 49:\n this.$ = { type: \"BreakSentence\" }; \nbreak;\ncase 50:\n this.$ = { type: \"ContinueSentence\" }; \nbreak;\ncase 53:\n\n      this.$ = {\n        type: \"IfSentence\",\n        test: $$[$0-2],\n        consequent: {\n          type: \"SentenceBlock\",\n          sentences: $$[$0]\n        },\n        alternate: null\n      };\n    \nbreak;\ncase 54:\n\n      this.$ = {\n        type: \"IfSentence\",\n        test: $$[$0-3],\n        consequent: {\n          type: \"SentenceBlock\",\n          sentences: $$[$0-1]\n        },\n        alternate: {\n          type: \"SentenceBlock\",\n          sentences: $$[$0]\n        },\n      };\n    \nbreak;\ncase 55:\n\n      this.$ = {\n        type: \"SwitchSentence\",\n        discriminant: $$[$0-2],\n        cases: $$[$0]\n      };\n    \nbreak;\ncase 56: case 62: case 66: case 92:\n this.$ = [$$[$0]]; \nbreak;\ncase 57: case 63:\n $$[$0-1].push($$[$0]); \nbreak;\ncase 59:\n this.$ = [$$[$0-1]]; \nbreak;\ncase 61:\n $$[$0-2].push($$[$0-1]); \nbreak;\ncase 64:\n\n      this.$ = {\n        type: \"SwitchCase\",\n        tests: $$[$0-2],\n        consequent: {\n          type: \"SentenceBlock\",\n          sentences: $$[$0]\n        }\n      };\n    \nbreak;\ncase 65:\n\n      this.$ = {\n        type: \"SwitchCase\",\n        tests: null,\n        consequent: {\n          type: \"SentenceBlock\",\n          sentences: $$[$0]\n        }\n      };\n    \nbreak;\ncase 67: case 93:\n $$[$0-2].push($$[$0]); \nbreak;\ncase 69:\n\n      this.$ = {\n        type: \"Range\",\n        min: $$[$0-2],\n        max: $$[$0]\n      };\n    \nbreak;\ncase 70:\n\n      this.$ = {\n        type: \"WhileSentence\",\n        test: $$[$0-2],\n        body: {\n          type: \"SentenceBlock\",\n          sentences: $$[$0]\n        }\n      };\n    \nbreak;\ncase 71:\n\n      this.$ = {\n        type: \"RepeatSentence\",\n        test: $$[$0].test,\n        body: {\n          type: \"SentenceBlock\",\n          sentences: $$[$0].body\n        }\n      };\n    \nbreak;\ncase 72:\n\n      this.$ = {\n        test: $$[$0],\n        body: []\n      };\n    \nbreak;\ncase 73:\n\n      this.$ = {\n        test: $$[$0],\n        body: $$[$0-1]\n      };\n    \nbreak;\ncase 75:\n\n      this.$ = {\n        type: \"LoopSentence\",\n        body: {\n          type: \"SentenceBlock\",\n          sentences: []\n        }\n      };\n    \nbreak;\ncase 76:\n\n      this.$ = {\n        type: \"FromSentence\",\n        identifier: $$[$0-7],\n        init: $$[$0-5],\n        limit: $$[$0-3],\n        step: $$[$0-2],\n        body: {\n          type: \"SentenceBlock\",\n          sentences: $$[$0]\n        }\n      };\n    \nbreak;\ncase 77:\n this.$ = null \nbreak;\ncase 78:\n this.$ = $$[$0]; \nbreak;\ncase 79:\n\n      this.$ = {\n        type: \"ForSentence\",\n        inits: $$[$0-1].inits,\n        tests: $$[$0-1].tests,\n        updates: $$[$0-1].updates,\n        body: {\n          type: \"SentenceBlock\",\n          sentences: $$[$0]\n        }\n      };\n    \nbreak;\ncase 80:\n\n      this.$ = {\n        inits: $$[$0-2],\n        tests: $$[$0-1],\n        updates: $$[$0]\n      };\n    \nbreak;\ncase 87:\n\n      this.$ = {\n        type: \"ReturnSentence\",\n        argument: null \n      };\n    \nbreak;\ncase 88:\n\n      this.$ = {\n        type: \"ReturnSentence\",\n        argument: $$[$0-1]\n      };\n    \nbreak;\ncase 89:\n\n      this.$ = {\n        type: \"FrameSentence\",\n        argument: null\n      };\n    \nbreak;\ncase 90:\n\n      this.$ = {\n        type: \"FrameSentence\",\n        argument: $$[$0-1]\n      };\n    \nbreak;\ncase 91:\n\n      this.$ = {\n        type: \"CloneSentence\",\n        body: {\n          type: \"SentenceBlock\",\n          sentences: $$[$0]\n        }\n      };\n    \nbreak;\ncase 95:\n\n      this.$ = {\n        type: \"Literal\",\n        value: JSON.parse($$[$0]),\n        raw: $$[$0]\n      };\n    \nbreak;\ncase 96:\n\n      this.$ = {\n        type: \"Literal\",\n        value: parseInt($$[$0]),\n        raw: $$[$0]\n      };\n    \nbreak;\ncase 102:\n\n      this.$ = {\n        type: \"UpdateExpression\",\n        operator: $$[$0],\n        argument: $$[$0-1],\n        prefix: false\n      };\n    \nbreak;\ncase 103:\n\n      this.$ = {\n        type: \"CallExpression\",\n        callee: $$[$0-2],\n        arguments: []\n      };\n    \nbreak;\ncase 104:\n\n      this.$ = {\n        type: \"CallExpression\",\n        callee: $$[$0-3],\n        arguments: $$[$0-1]\n      };\n    \nbreak;\ncase 106:\n\n      this.$ = {\n        type: \"UpdateExpression\",\n        operator: $$[$0-1],\n        argument: $$[$0],\n        prefix: true\n      };\n    \nbreak;\ncase 141:\n\n      this.$ = {\n        type: \"AssignmentExpression\",\n        operator: $$[$0-1],\n        left: $$[$0-2],\n        right: $$[$0]\n      };\n    \nbreak;\n}\n},\ntable: [{3:1,4:2,7:[1,3]},{1:[3]},{5:[1,4],6:5,36:6,37:$V0},{8:8,15:$V1},{1:[2,1]},{5:[1,10],36:11,37:$V0},o($V2,[2,29]),{8:12,15:$V1},{9:[1,13]},o($V3,[2,4]),{1:[2,2]},o($V2,[2,30]),{9:[1,14]},o($V4,[2,6],{10:15,16:[1,16]}),{13:17,21:$V5,38:$V6},o($V7,[2,8],{11:19,18:[1,20]}),o($V8,[2,13],{17:21}),{14:22,38:$V9},o([27,28,29,30,31,32,33,34,35,38],$Va,{19:24}),o($Vb,[2,10],{12:25,20:[1,26]}),o($Vc,$Va,{19:27}),o($V4,[2,5],{22:28,8:29,15:$V1}),o($V2,[2,31]),{8:76,15:$V1,24:45,39:30,40:$Vd,41:32,44:33,45:34,46:35,47:36,48:37,50:38,51:39,52:40,53:41,54:42,55:43,56:$Ve,57:$Vf,58:$Vg,59:$Vh,60:$Vi,62:$Vj,74:$Vk,75:$Vl,79:$Vm,80:$Vn,84:$Vo,90:$Vp,91:$Vq,92:$Vr,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{25:85,26:86,27:$VB,28:$VC,29:$VD,30:$VE,31:$VF,32:$VG,33:$VH,34:$VI,35:$VJ,38:[2,11]},{13:96,21:$V5,38:$V6},o([21,27,28,29,30,31,32,33,34,35,38],$Va,{19:97}),o($V7,[2,7],{25:85,26:86,27:$VB,28:$VC,29:$VD,30:$VE,31:$VF,32:$VG,33:$VH,34:$VI,35:$VJ}),o($V8,[2,14]),{23:[1,98]},o($V2,[2,32]),o($VK,[2,33]),{8:76,15:$V1,24:45,40:$VL,44:100,45:34,46:35,47:36,48:37,50:38,51:39,52:40,53:41,54:42,55:43,56:$Ve,57:$Vf,58:$Vg,59:$Vh,60:$Vi,62:$Vj,74:$Vk,75:$Vl,79:$Vm,80:$Vn,84:$Vo,90:$Vp,91:$Vq,92:$Vr,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},o($VM,[2,56]),o($VM,[2,37]),o($VM,[2,38]),o($VM,[2,39]),o($VM,[2,51],{49:101,9:[1,102]}),o($VM,[2,41]),o($VM,[2,42]),o($VM,[2,43]),{9:[1,103]},{9:[1,104]},o($VM,[2,46]),{9:[1,105]},{9:[1,106]},{9:[1,107]},{9:[1,108]},{60:[1,109]},{60:[1,110]},{60:[1,111]},{8:76,15:$V1,24:45,41:114,44:33,45:34,46:35,47:36,48:37,50:38,51:39,52:40,53:41,54:42,55:43,56:$Ve,57:$Vf,58:$Vg,59:$Vh,60:$Vi,62:$Vj,74:$Vk,75:$Vl,76:112,77:113,78:$VN,79:$Vm,80:$Vn,84:$Vo,90:$Vp,91:$Vq,92:$Vr,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{8:76,15:$V1,24:45,39:116,40:$Vd,41:32,44:33,45:34,46:35,47:36,48:37,50:38,51:39,52:40,53:41,54:42,55:43,56:$Ve,57:$Vf,58:$Vg,59:$Vh,60:$Vi,62:$Vj,74:$Vk,75:$Vl,79:$Vm,80:$Vn,84:$Vo,90:$Vp,91:$Vq,92:$Vr,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{8:117,15:$V1},{60:[1,119],85:118},{9:[2,87],60:[1,120]},{9:[2,89],60:[1,121]},{8:76,15:$V1,24:45,39:122,40:$Vd,41:32,44:33,45:34,46:35,47:36,48:37,50:38,51:39,52:40,53:41,54:42,55:43,56:$Ve,57:$Vf,58:$Vg,59:$Vh,60:$Vi,62:$Vj,74:$Vk,75:$Vl,79:$Vm,80:$Vn,84:$Vo,90:$Vp,91:$Vq,92:$Vr,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},o($VO,[2,153]),o($VO,[2,140]),o($VP,$VQ,{134:123,23:[1,124],135:[1,125],136:[1,126],137:[1,127],138:[1,128],139:[1,129],140:[1,130],141:[1,131],142:[1,132],143:[1,133],144:[1,134]}),o($VO,[2,139],{131:[1,135]}),o($VR,[2,105],{101:138,60:[1,139],97:[1,136],100:[1,137],104:$Vu,105:$Vv}),{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:140,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA},{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:141,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA},o($VS,[2,137],{129:$VT}),o($V3,[2,98]),o($V3,[2,100]),o($VU,[2,108]),o($VU,[2,109]),o($VV,[2,110]),o($VV,[2,111]),o($VV,[2,112]),o($VV,[2,113]),o($VV,[2,114]),o($VW,[2,135],{127:$VX}),o($V3,[2,94]),o($V3,[2,95]),o($V3,[2,96]),{8:76,15:$V1,24:144,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},o($VY,[2,133],{124:$VZ,125:$V_}),o($V$,[2,130],{119:$V01,120:$V11,121:$V21,122:$V31}),o($V41,[2,125],{116:$V51,117:$V61}),o($V71,[2,122],{108:$V81,109:$V91}),o($Va1,[2,119],{107:$Vb1,112:$Vc1,113:$Vd1}),o($Vc,[2,17]),{8:158,15:$V1},{15:[2,20]},{15:[2,21]},{15:[2,22]},{15:[2,23]},{15:[2,24]},{15:[2,25]},{15:[2,26]},{15:[2,27]},{15:[2,28]},{14:159,38:$V9},o($Vb,[2,9],{25:85,26:86,27:$VB,28:$VC,29:$VD,30:$VE,31:$VF,32:$VG,33:$VH,34:$VI,35:$VJ}),{8:76,15:$V1,24:160,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},o($VK,[2,34]),o($VM,[2,57]),o($VM,[2,40]),o($VM,[2,52]),o($VM,[2,44]),o($VM,[2,45]),o($VM,[2,47]),o($VM,[2,48]),o($VM,[2,49]),o($VM,[2,50]),{8:76,15:$V1,24:161,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{8:76,15:$V1,24:162,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{8:76,15:$V1,24:163,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},o($Ve1,[2,71]),o($Ve1,[2,72]),{8:76,15:$V1,24:45,44:100,45:34,46:35,47:36,48:37,50:38,51:39,52:40,53:41,54:42,55:43,56:$Ve,57:$Vf,58:$Vg,59:$Vh,60:$Vi,62:$Vj,74:$Vk,75:$Vl,77:164,78:$VN,79:$Vm,80:$Vn,84:$Vo,90:$Vp,91:$Vq,92:$Vr,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{60:[1,165]},o($VM,[2,75]),{23:[1,166]},{8:76,15:$V1,24:45,39:167,40:$Vd,41:32,44:33,45:34,46:35,47:36,48:37,50:38,51:39,52:40,53:41,54:42,55:43,56:$Ve,57:$Vf,58:$Vg,59:$Vh,60:$Vi,62:$Vj,74:$Vk,75:$Vl,79:$Vm,80:$Vn,84:$Vo,90:$Vp,91:$Vq,92:$Vr,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{8:76,9:[1,169],15:$V1,24:171,60:$Vi,86:168,89:170,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{8:76,15:$V1,24:172,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{8:76,15:$V1,24:173,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},o($VM,[2,91]),{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:174},o($VV,[2,142]),o($VV,[2,143]),o($VV,[2,144]),o($VV,[2,145]),o($VV,[2,146]),o($VV,[2,147]),o($VV,[2,148]),o($VV,[2,149]),o($VV,[2,150]),o($VV,[2,151]),o($VV,[2,152]),{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:176,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:175},{8:76,15:$V1,24:177,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{8:178,15:$V1},o($V3,[2,102]),{8:76,15:$V1,24:171,60:$Vi,61:[1,179],89:180,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},o($VR,[2,106]),o($VR,[2,107]),{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:176,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:181},{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:176,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:182},{61:[1,183]},{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:176,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:184},{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:176,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:185},{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:176,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:186},{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:176,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:187},{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:176,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:188},{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:176,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:189},{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:176,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:190},{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:176,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:191},{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:176,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:192},{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:176,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:193},{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:194,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA},{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:195,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA},{8:76,15:$V1,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:196,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA},{9:[1,198],23:[1,197]},o($V2,[2,3]),{9:[1,199]},{61:[1,200]},{61:[1,201]},{61:[1,202]},o($Ve1,[2,73]),{8:76,15:$V1,24:203,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{8:76,15:$V1,24:204,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},o($VM,[2,79]),{8:76,9:[1,206],15:$V1,24:171,60:$Vi,87:205,89:207,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},o($Vf1,[2,81]),{9:[1,208],72:$Vg1},o($Vh1,[2,92]),{61:[1,210]},{61:[1,211]},o($VO,[2,141]),o($VS,[2,138],{129:$VT}),o($VP,$VQ),{98:[1,212]},o($V3,[2,101]),o($V3,[2,103]),{61:[1,213],72:$Vg1},o($VW,[2,136],{127:$VX}),o($VY,[2,134],{124:$VZ,125:$V_}),o($V3,[2,97]),o($V$,[2,131],{119:$V01,120:$V11,121:$V21,122:$V31}),o($V$,[2,132],{119:$V01,120:$V11,121:$V21,122:$V31}),o($V41,[2,126],{116:$V51,117:$V61}),o($V41,[2,127],{116:$V51,117:$V61}),o($V41,[2,128],{116:$V51,117:$V61}),o($V41,[2,129],{116:$V51,117:$V61}),o($V71,[2,123],{108:$V81,109:$V91}),o($V71,[2,124],{108:$V81,109:$V91}),o($Va1,[2,120],{107:$Vb1,112:$Vc1,113:$Vd1}),o($Va1,[2,121],{107:$Vb1,112:$Vc1,113:$Vd1}),o($VP,[2,116]),o($VP,[2,117]),o($VP,[2,118]),{8:76,15:$V1,24:214,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},o($Vc,[2,19]),o($V8,[2,15]),{8:76,15:$V1,24:45,39:215,40:$Vd,41:217,42:216,43:[1,218],44:33,45:34,46:35,47:36,48:37,50:38,51:39,52:40,53:41,54:42,55:43,56:$Ve,57:$Vf,58:$Vg,59:$Vh,60:$Vi,62:$Vj,74:$Vk,75:$Vl,79:$Vm,80:$Vn,84:$Vo,90:$Vp,91:$Vq,92:$Vr,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{40:[1,220],63:219,64:221,65:222,66:224,67:$Vi1,70:$Vj1},{8:76,15:$V1,24:45,39:226,40:$Vd,41:32,44:33,45:34,46:35,47:36,48:37,50:38,51:39,52:40,53:41,54:42,55:43,56:$Ve,57:$Vf,58:$Vg,59:$Vh,60:$Vi,62:$Vj,74:$Vk,75:$Vl,79:$Vm,80:$Vn,84:$Vo,90:$Vp,91:$Vq,92:$Vr,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{61:[1,227]},{81:[1,228]},{8:76,15:$V1,24:171,60:$Vi,61:[1,230],88:229,89:231,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},o($Vk1,[2,83]),{9:[1,232],72:$Vg1},o($Vf1,[2,82]),{8:76,15:$V1,24:233,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{9:[2,88]},{9:[2,90]},o($V3,[2,99]),o($V3,[2,104]),{9:[1,234]},o($VM,[2,53]),{8:76,15:$V1,24:45,39:235,40:$Vd,41:32,44:33,45:34,46:35,47:36,48:37,50:38,51:39,52:40,53:41,54:42,55:43,56:$Ve,57:$Vf,58:$Vg,59:$Vh,60:$Vi,62:$Vj,74:$Vk,75:$Vl,79:$Vm,80:$Vn,84:$Vo,90:$Vp,91:$Vq,92:$Vr,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{8:76,15:$V1,24:45,40:$VL,43:[1,236],44:100,45:34,46:35,47:36,48:37,50:38,51:39,52:40,53:41,54:42,55:43,56:$Ve,57:$Vf,58:$Vg,59:$Vh,60:$Vi,62:$Vj,74:$Vk,75:$Vl,79:$Vm,80:$Vn,84:$Vo,90:$Vp,91:$Vq,92:$Vr,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},o($Vl1,[2,35]),o($VM,[2,55]),o($VM,[2,58]),{40:[1,237]},{40:[1,238],64:239,66:240,67:$Vi1,70:$Vj1},{69:[1,241]},o($Vm1,[2,62]),{8:76,15:$V1,24:244,60:$Vi,68:242,71:243,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},o($VM,[2,70]),o($Ve1,[2,74]),{8:76,15:$V1,24:245,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},o($Vl1,[2,80]),o($Vl1,[2,85]),{61:[1,246],72:$Vg1},o($Vk1,[2,84]),o($Vh1,[2,93]),o($Vc,[2,18]),o($VM,[2,54]),o($Vl1,[2,36]),o($VM,[2,59]),o($VM,[2,60]),{40:[1,247]},o($Vm1,[2,63]),{8:76,15:$V1,24:45,39:248,40:$Vd,41:32,44:33,45:34,46:35,47:36,48:37,50:38,51:39,52:40,53:41,54:42,55:43,56:$Ve,57:$Vf,58:$Vg,59:$Vh,60:$Vi,62:$Vj,74:$Vk,75:$Vl,79:$Vm,80:$Vn,84:$Vo,90:$Vp,91:$Vq,92:$Vr,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{69:[1,249],72:[1,250]},o($Vn1,[2,66]),o($Vn1,[2,68],{73:[1,251]}),{9:[2,77],82:252,83:[1,253]},o($Vl1,[2,86]),o($VM,[2,61]),{40:[2,65]},{8:76,15:$V1,24:45,39:254,40:$Vd,41:32,44:33,45:34,46:35,47:36,48:37,50:38,51:39,52:40,53:41,54:42,55:43,56:$Ve,57:$Vf,58:$Vg,59:$Vh,60:$Vi,62:$Vj,74:$Vk,75:$Vl,79:$Vm,80:$Vn,84:$Vo,90:$Vp,91:$Vq,92:$Vr,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{8:76,15:$V1,24:244,60:$Vi,71:255,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{8:76,15:$V1,24:256,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{9:[1,257]},{8:76,15:$V1,24:258,60:$Vi,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},o($Vm1,[2,64]),o($Vn1,[2,67]),o($Vn1,[2,69]),{8:76,15:$V1,24:45,39:259,40:$Vd,41:32,44:33,45:34,46:35,47:36,48:37,50:38,51:39,52:40,53:41,54:42,55:43,56:$Ve,57:$Vf,58:$Vg,59:$Vh,60:$Vi,62:$Vj,74:$Vk,75:$Vl,79:$Vm,80:$Vn,84:$Vo,90:$Vp,91:$Vq,92:$Vr,93:66,94:$Vs,95:$Vt,96:62,99:67,101:63,102:60,103:64,104:$Vu,105:$Vv,106:$Vw,107:$Vx,108:$Vy,109:$Vz,110:$VA,111:84,114:83,115:82,118:81,123:80,126:75,128:65,130:61,132:59,133:58},{9:[2,78]},o($VM,[2,76])],\ndefaultActions: {4:[2,1],10:[2,2],87:[2,20],88:[2,21],89:[2,22],90:[2,23],91:[2,24],92:[2,25],93:[2,26],94:[2,27],95:[2,28],210:[2,88],211:[2,90],248:[2,65],258:[2,78]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        function _parseError (msg, hash) {\n            this.message = msg;\n            this.hash = hash;\n        }\n        _parseError.prototype = Error;\n\n        throw new _parseError(str, hash);\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        var lex = function () {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        };\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n\n/* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {\"case-insensitive\":true},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0: /* ignore */ \nbreak;\ncase 1: return 59; \nbreak;\ncase 2: return 43; \nbreak;\ncase 3: return 62; \nbreak;\ncase 4: return 67; \nbreak;\ncase 5: return 70; \nbreak;\ncase 6: return 79; \nbreak;\ncase 7: return 80; \nbreak;\ncase 8: return 75; \nbreak;\ncase 9: return 78; \nbreak;\ncase 10: return 74; \nbreak;\ncase 11: return 80; \nbreak;\ncase 12: return 81; \nbreak;\ncase 13: return 83; \nbreak;\ncase 14: return 84; \nbreak;\ncase 15: return 57; \nbreak;\ncase 16: return 58; \nbreak;\ncase 17: return 90; \nbreak;\ncase 18: return 91; \nbreak;\ncase 19: return 92; \nbreak;\ncase 20: return 56; \nbreak;\ncase 21: return 91; \nbreak;\ncase 22: return 7; \nbreak;\ncase 23: return 16; \nbreak;\ncase 24: return 18; \nbreak;\ncase 25: return 20; \nbreak;\ncase 26: return 21; \nbreak;\ncase 27: return 37; \nbreak;\ncase 28: return 'FUNCTION'; \nbreak;\ncase 29: return 38; \nbreak;\ncase 30: return 40; \nbreak;\ncase 31: return 27; \nbreak;\ncase 32: return 28; \nbreak;\ncase 33: return 29; \nbreak;\ncase 34: return 30; \nbreak;\ncase 35: return 31; \nbreak;\ncase 36: return 32; \nbreak;\ncase 37: return 33; \nbreak;\ncase 38: return 34; \nbreak;\ncase 39: return 35; \nbreak;\ncase 40: return 9; \nbreak;\ncase 41: return 60; \nbreak;\ncase 42: return 61; \nbreak;\ncase 43: return 97; \nbreak;\ncase 44: return 98; \nbreak;\ncase 45: return 72; \nbreak;\ncase 46: return 23; \nbreak;\ncase 47: return 138; \nbreak;\ncase 48: return 139; \nbreak;\ncase 49: return 136; \nbreak;\ncase 50: return 135; \nbreak;\ncase 51: return 137; \nbreak;\ncase 52: return 142; \nbreak;\ncase 53: return 144; \nbreak;\ncase 54: return 143; \nbreak;\ncase 55: return 140; \nbreak;\ncase 56: return 141; \nbreak;\ncase 57: return 124; \nbreak;\ncase 58: return 122; \nbreak;\ncase 59: return '=>'; \nbreak;\ncase 60: return 121; \nbreak;\ncase 61: return 125; \nbreak;\ncase 62: return 125; \nbreak;\ncase 63: return 119; \nbreak;\ncase 64: return 120; \nbreak;\ncase 65: return 127; \nbreak;\ncase 66: return 127; \nbreak;\ncase 67: return 106; \nbreak;\ncase 68: return 131; \nbreak;\ncase 69: return 131; \nbreak;\ncase 70: return '^^'; \nbreak;\ncase 71: return '^^'; \nbreak;\ncase 72: return 129; \nbreak;\ncase 73: return 117; \nbreak;\ncase 74: return 116; \nbreak;\ncase 75: return 104; \nbreak;\ncase 76: return 105; \nbreak;\ncase 77: return 108; \nbreak;\ncase 78: return 109; \nbreak;\ncase 79: return 23; \nbreak;\ncase 80: return 112; \nbreak;\ncase 81: return 107; \nbreak;\ncase 82: return 113; \nbreak;\ncase 83: return 113; \nbreak;\ncase 84: return 110; \nbreak;\ncase 85: return 110; \nbreak;\ncase 86: return 106; \nbreak;\ncase 87: return 107; \nbreak;\ncase 88: return 73; \nbreak;\ncase 89: return 69; \nbreak;\ncase 90: return 100; \nbreak;\ncase 91: return 94; \nbreak;\ncase 92: return 95; \nbreak;\ncase 93: return 15; \nbreak;\ncase 94: return 5; \nbreak;\n}\n},\nrules: [/^(?:\\s+)/i,/^(?:IF\\b)/i,/^(?:ELSE\\b)/i,/^(?:SWITCH\\b)/i,/^(?:CASE\\b)/i,/^(?:DEFAULT\\b)/i,/^(?:LOOP\\b)/i,/^(?:FROM\\b)/i,/^(?:REPEAT\\b)/i,/^(?:UNTIL\\b)/i,/^(?:WHILE\\b)/i,/^(?:FROM\\b)/i,/^(?:TO\\b)/i,/^(?:STEP\\b)/i,/^(?:FOR\\b)/i,/^(?:BREAK\\b)/i,/^(?:CONTINUE\\b)/i,/^(?:RETURN\\b)/i,/^(?:FRAME\\b)/i,/^(?:CLONE\\b)/i,/^(?:DEBUG\\b)/i,/^(?:FRAME\\b)/i,/^(?:PROGRAM\\b)/i,/^(?:CONST\\b)/i,/^(?:GLOBAL\\b)/i,/^(?:LOCAL\\b)/i,/^(?:PRIVATE\\b)/i,/^(?:PROCESS\\b)/i,/^(?:FUNCTION\\b)/i,/^(?:BEGIN\\b)/i,/^(?:END\\b)/i,/^(?:INT POINTER\\b)/i,/^(?:INT\\b)/i,/^(?:WORD POINTER\\b)/i,/^(?:WORD\\b)/i,/^(?:BYTE POINTER\\b)/i,/^(?:BYTE\\b)/i,/^(?:STRING POINTER\\b)/i,/^(?:STRING\\b)/i,/^(?:STRUCT POINTER\\b)/i,/^(?:;)/i,/^(?:\\()/i,/^(?:\\))/i,/^(?:\\[)/i,/^(?:\\])/i,/^(?:,)/i,/^(?::=)/i,/^(?:\\+=)/i,/^(?:-=)/i,/^(?:\\/=)/i,/^(?:\\*=)/i,/^(?:%=)/i,/^(?:&=)/i,/^(?:\\|=)/i,/^(?:\\^=)/i,/^(?:<<=)/i,/^(?:>>=)/i,/^(?:==)/i,/^(?:>=)/i,/^(?:=>)/i,/^(?:<=)/i,/^(?:<>)/i,/^(?:!=)/i,/^(?:<)/i,/^(?:>)/i,/^(?:AND\\b)/i,/^(?:&&)/i,/^(?:&)/i,/^(?:OR\\b)/i,/^(?:\\|\\|)/i,/^(?:XOR\\b)/i,/^(?:\\^\\^)/i,/^(?:\\^)/i,/^(?:>>)/i,/^(?:<<)/i,/^(?:\\+\\+)/i,/^(?:--)/i,/^(?:\\+)/i,/^(?:-)/i,/^(?:=)/i,/^(?:\\/)/i,/^(?:\\*)/i,/^(?:MOD\\b)/i,/^(?:%)/i,/^(?:NOT\\b)/i,/^(?:!)/i,/^(?:OFFSET\\b)/i,/^(?:POINTER\\b)/i,/^(?:\\.\\.)/i,/^(?::)/i,/^(?:\\.)/i,/^(?:(\"\")|(\".*?([^\\\\]\")))/i,/^(?:[0-9]+)/i,/^(?:([a-z#$_][0-9a-z#$_]*))/i,/^(?:$)/i],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nreturn parser;\n});\n",
    "\ndefine('symbols',[], function () {\n  'use strict';\n\n  return {\n    isGlobal: function (name) {\n      return this.wellKnownGlobals.indexOf(name.toLowerCase()) >= 0;\n    },\n\n    isLocal: function (name) {\n      name = name.toLowerCase();\n      // TODO: Actually, id is a special token, non an identifier. Let's fix\n      // that in the parser and translation module.\n      // TODO: Second clause is wrong as local definitions can be not simply\n      // strings.\n      return name === 'id' || this.wellKnownLocals.indexOf(name) >= 0;\n    },\n\n    wellKnownGlobals: [\n      'text_z'\n    ],\n\n    wellKnownLocals: [\n      {\n        'type': 'struct',\n        'name': 'reserved',\n        'fields': [\n          'process_id',\n          'id_scan',\n          'process_type',\n          'type_scan',\n          'status',\n          'parameters',\n          'param_offset',\n          'program_index',\n          'stack_pointer',\n          'is_executed',\n          'is_painted',\n          'm8_object',\n          'old_ctype',\n          'frame_percent',\n          'box_x0',\n          'box_y0',\n          'box_x1',\n          'box_y1',\n          'f_count',\n          'caller_id'\n        ]\n      },\n      'father',\n      'son',\n      'smallbro',\n      'bigbro',\n      'priority',\n      'ctype',\n      'x',\n      'y',\n      'z',\n      'graph',\n      'flags',\n      'size',\n      'angle',\n      'region',\n      'file',\n      'xgraph',\n      'cnumber',\n      'height',\n      'resolution',\n      'radius',\n      'm8_wall',\n      'm8_sector',\n      'm8_nextsector',\n      'm8_step'\n    ]\n  };\n});\n\n",
    "\ndefine('ast',[], function () {\n  'use strict';\n\n  function Node() {}\n\n  Node.prototype.pojo = function () {\n    return JSON.parse(JSON.stringify(this));\n  };\n\n  function AssignmentExpression(left, right, operator) {\n    operator = operator || '=';\n    this.type = 'AssignmentExpression';\n    this.operator = operator;\n    this.left = left;\n    this.right = right;\n  }\n  inherits(AssignmentExpression, Node);\n\n  function ArrayExpression(elements) {\n    this.type = 'ArrayExpression';\n    this.elements = elements || [];\n  }\n  inherits(AssignmentExpression, Node);\n\n  function BinaryExpression(left, right, operator) {\n    this.type = 'BinaryExpression';\n    this.operator = operator;\n    this.left = left;\n    this.right = right;\n  }\n  inherits(BinaryExpression, Node);\n\n  function BlockStatement(statements) {\n    if (!Array.isArray(statements)) { statements = [statements]; }\n    this.type = 'BlockStatement';\n    this.body = statements;\n  }\n  inherits(BlockStatement, Node);\n\n  function BreakStatement(label) {\n    this.type = 'BreakStatement';\n    this.label = label || null;\n  }\n  inherits(BreakStatement, Node);\n\n  function CallExpression(callee, args) {\n    this.type = 'CallExpression';\n    this.callee = callee;\n    this.arguments = args;\n  }\n  inherits(CallExpression, Node);\n\n  function ConditionalExpression(test, consequent, alternate) {\n    this.type = 'ConditionalExpression';\n    this.test = test;\n    this.consequent = consequent;\n    this.alternate = alternate;\n  }\n  inherits(ConditionalExpression, Node);\n\n  function ExpressionStatement(expression) {\n    this.type = 'ExpressionStatement';\n    this.expression = expression;\n  }\n  inherits(ExpressionStatement, Node);\n\n  /* jshint maxparams: 6 */\n  function FunctionDeclaration(id, params, defaults, body,\n                               generator, expression) {\n    this.type = 'FunctionDeclaration';\n    this.id = id || null;\n    this.params = params || [];\n    this.defaults = defaults || [];\n    this.body = new BlockStatement(body);\n    this.generator = generator || false;\n    this.expression = expression || false;\n  }\n  inherits(FunctionDeclaration, Node);\n\n  function Identifier(name) {\n    this.type = 'Identifier';\n    this.name = name;\n  }\n  inherits(Identifier, Node);\n\n  function Literal(value) {\n    if (typeof value === 'number' && value < 0) {\n      throw new Error(\n        'Can not construct negative literals. Negative literals are ' +\n        'formed by negating a positive literal. Use `Literal.for()` which ' +\n        'return either a literal or an expression for a negative literal.'\n      );\n    }\n    this.type = 'Literal';\n    this.value = value;\n    this.raw = JSON.stringify(value);\n  }\n  inherits(Literal, Node);\n\n  Literal.for = function (value) {\n    if (typeof value === 'number' && value < 0) {\n      return new UnaryExpression(new Literal(Math.abs(value)), '-');\n    }\n    return new Literal(value);\n  };\n\n  function LogicalExpression(left, right, operator) {\n    this.type = 'LogicalExpression';\n    this.operator = operator;\n    this.left = left;\n    this.right = right;\n  }\n  inherits(LogicalExpression, Node);\n\n  function MemberExpression(object, property, computed) {\n    this.type = 'MemberExpression',\n    this.computed = computed || false;\n    this.object = object;\n    this.property = property;\n  }\n  inherits(MemberExpression, Node);\n\n  function Program(body) {\n    this.type = 'Program';\n    this.body = body;\n  }\n  inherits(Program, Node);\n\n  function ReturnStatement(expression) {\n    this.type = 'ReturnStatement';\n    this.argument = expression || null;\n  }\n  inherits(ReturnStatement, Node);\n\n  function SwitchCase(test, sentences) {\n    this.type = 'SwitchCase';\n    this.test = test;\n    this.consequent = sentences || [];\n  }\n  inherits(SwitchCase, Node);\n\n  function SwitchStatement(discriminant, cases) {\n    this.type = 'SwitchStatement';\n    this.discriminant = discriminant;\n    this.cases = cases || [];\n  }\n  inherits(SwitchStatement, Node);\n\n  function UnaryExpression(argument, operator, prefix) {\n    this.type = 'UnaryExpression';\n    this.operator = operator;\n    this.argument = argument;\n    this.prefix = typeof prefix === 'undefined' ? true : prefix;\n  }\n  inherits(UnaryExpression, Node);\n\n  function VariableDeclaration(declarations, kind) {\n    if (!Array.isArray(declarations)) { declarations = [declarations]; }\n    this.type = 'VariableDeclaration';\n    this.declarations = declarations;\n    this.kind = kind || 'var';\n  }\n  inherits(VariableDeclaration, Node);\n\n  function VariableDeclarator(id, init) {\n    this.type = 'VariableDeclarator';\n    this.id = id;\n    this.init = init;\n  }\n  inherits(VariableDeclarator, Node);\n\n  function WhileStatement(condition, statements) {\n    this.type = 'WhileStatement';\n    this.test = condition;\n    this.body = new BlockStatement(statements);\n  }\n  inherits(WhileStatement, Node);\n\n  function inherits(klass, base) {\n    klass.prototype = Object.create(base.prototype);\n    klass.prototype.constructor = klass;\n  }\n\n  return {\n    AssignmentExpression: AssignmentExpression,\n    ArrayExpression: ArrayExpression,\n    BinaryExpression: BinaryExpression,\n    BlockStatement: BlockStatement,\n    BreakStatement: BreakStatement,\n    CallExpression: CallExpression,\n    ConditionalExpression: ConditionalExpression,\n    ExpressionStatement: ExpressionStatement,\n    FunctionDeclaration: FunctionDeclaration,\n    Identifier: Identifier,\n    Literal: Literal,\n    LogicalExpression: LogicalExpression,\n    MemberExpression: MemberExpression,\n    Program: Program,\n    ReturnStatement: ReturnStatement,\n    SwitchCase: SwitchCase,\n    SwitchStatement: SwitchStatement,\n    UnaryExpression: UnaryExpression,\n    VariableDeclaration: VariableDeclaration,\n    VariableDeclarator: VariableDeclarator,\n    WhileStatement: WhileStatement\n  };\n});\n\n",
    "\ndefine('templates',['ast'], function (ast) {\n  'use strict';\n\n  return {\n\n    callWith: function (name, args) {\n      if (!Array.isArray(args)) {\n        args = args ? [args] : [];\n      }\n      return new ast.CallExpression(new ast.Identifier(name), args);\n    },\n\n    concurrentBody: function (cases) {\n      var programCounter = this.programCounter;\n      var switchStatement = new ast.SwitchStatement(programCounter, cases);\n      return this.infiniteLoop(switchStatement);\n    },\n\n    concurrentLabel: function (label) {\n      return new ast.SwitchCase(ast.Literal.for(label));\n    },\n\n    get endToken() {\n      return {\n        type: 'Identifier',\n        name: '__yieldEnd'\n      };\n    },\n\n    every: function (tests) {\n      var _this = this;\n      return tests.reduce(function (chain, test) {\n        return chain === null ? test :\n               new ast.LogicalExpression(chain, test, '&&');\n      }, null);\n    },\n\n    /**\n     * Builds a DIV2 AST for a FROM update.\n     *\n     * @return a DIV2 increment expression.\n     * TODO: Maybe a set of DIV2 constructors is actually needed.\n     */\n    fromIncrement: function (name, constant) {\n      return {\n        type: 'AssignmentExpression',\n        operator: '+=',\n        left: {\n          type: 'Identifier',\n          name: name\n        },\n        right: {\n          type: 'Literal',\n          value: constant,\n          raw: JSON.stringify(constant)\n        }\n      };\n    },\n\n    /**\n     * Builds a DIV2 AST for a FROM initializator.\n     *\n     * @return a DIV2 assignment expression.\n     * TODO: Maybe a set of DIV2 constructors is actually needed.\n     */\n    fromInitilizator: function (name, constant) {\n      return {\n        type: 'AssignmentExpression',\n        operator: '=',\n        left: {\n          type: 'Identifier',\n          name: name\n        },\n        right: {\n          type: 'Literal',\n          value: constant,\n          raw: JSON.stringify(constant)\n        }\n      };\n    },\n\n    /**\n     * Builds a DIV2 AST for FROM test.\n     *\n     * @return a DIV2 comparison expression.\n     * TODO: Maybe a set of DIV2 constructors is actually needed.\n     */\n    fromTest: function (name, constant, isLowerThan) {\n      return {\n        type: 'BinaryExpression',\n        operator: isLowerThan ? '<=' : '>=',\n        left: {\n          type: 'Identifier',\n          name: name\n        },\n        right: {\n          type: 'Literal',\n          value: constant,\n          raw: JSON.stringify(constant)\n        }\n      };\n    },\n\n    /**\n     * Builds a DIV2 AST for the default argument for FRAME.\n     *\n     * @return a DIV2 comparison expression.\n     * TODO: Maybe a set of DIV2 constructors is actually needed.\n     */\n    get defaultFrameArgument() {\n      return {\n        type: \"Literal\",\n        value: 100,\n        raw: \"100\"\n      };\n    },\n\n    /**\n     * Builds a DIV2 AST for the default argument for RETURN (process id).\n     *\n     * @return a DIV2 comparison expression.\n     * TODO: Maybe a set of DIV2 constructors is actually needed.\n     */\n    get defaultReturnArgument() {\n      return {\n        type: \"Identifier\",\n        name: \"id\"\n      };\n    },\n\n    infiniteLoop: function (body) {\n      return new ast.WhileStatement(this.trueLiteral, body);\n    },\n\n    labeledBlock: function (label) {\n      return new ast.SwitchCase(ast.Literal.for(label));\n    },\n\n    memoryGlobal: function (name) {\n      return this._memory(name, this._globalAddress(name));\n    },\n\n    //TODO: Wrong, implement as mem[exec.local_base + L_NAME]\n    memoryLocal: function (name) {\n      return this._memory(name, new ast.Identifier(name));\n    },\n\n    //TODO: Wrong, implement as mem[exec.local_base + name]\n    memoryPrivate: function (name) {\n      return this.memoryLocal(name);\n    },\n\n    _memory: function (name, index) {\n      return new ast.MemberExpression(new ast.Identifier('mem'), index, true);\n    },\n\n    _globalAddress: function (name) {\n      return {\n        type: 'BinaryExpression',\n        operator: '+',\n        left: this.globalBaseIdentifier,\n        right: this.identifierForGlobal(name)\n      };\n    },\n\n    globalBaseIdentifier: new ast.Identifier('G_BASE'),\n\n    identifierForGlobal: function (name) {\n      return new ast.Identifier('G_' + name.toUpperCase());\n    },\n\n    newRange: function (min, max) {\n      return this.callWith('__range', [min, max]);\n    },\n\n    get processEnd() {\n      return new ast.ReturnStatement(this.endToken);\n    },\n\n    call: function (kind, resume, name, argList) {\n      var yieldType = {\n        'function': '__yieldCallFunction',\n        'process': '__yieldNewProcess'\n      }[kind];\n      return new ast.ReturnStatement(\n        this.callWith(\n          yieldType,\n          [ast.Literal.for(resume), ast.Literal.for(name)].concat(argList)\n        )\n      );\n    },\n\n    processClone: function (child, parent) {\n      return new ast.ReturnStatement(\n        this.callWith(\n          '__yieldClone',\n          [ast.Literal.for(child), ast.Literal.for(parent)]\n        )\n      );\n    },\n\n    // TODO: Ok, the former means process clone but what does this mean?\n    // It is not \"process frame\", it is just frame.\n    processFrame: function (resume, expression) {\n      return new ast.ReturnStatement(\n        this.callWith(\n          '__yieldFrame',\n          [ast.Literal.for(resume), expression]\n        )\n      );\n    },\n\n    // TODO: Same here.\n    processDebug: function (resume) {\n      return new ast.ReturnStatement(\n        this.callWith(\n          '__yieldDebug',\n          [ast.Literal.for(resume)]\n        )\n      );\n    },\n\n    programFunction: function (name, body) {\n      return new ast.FunctionDeclaration(\n        new ast.Identifier('program_' + name),\n        this.processParameters, null,\n        body\n      );\n    },\n\n    processFunction: function (name, body) {\n      return new ast.FunctionDeclaration(\n        new ast.Identifier('process_' + name),\n        this.processParameters, null,\n        body\n      );\n    },\n\n    // TODO: Maybe mem, exec & args should be supplied by div2trans\n    get processParameters() {\n      return [\n        new ast.Identifier('mem'),\n        new ast.Identifier('exec'),\n        new ast.Identifier('args')\n      ];\n    },\n\n    // TODO: See my comment about processFrame. I don't think this should be\n    // different for a process than for a function.\n    processReturn: function (expression) {\n      return new ast.ReturnStatement(\n        this.callWith(\n          '__yieldReturn',\n          expression\n        )\n      );\n    },\n\n    get programCounter() {\n      return new ast.MemberExpression(\n        new ast.Identifier('exec'),\n        new ast.Identifier('pc')\n      );\n    },\n\n    get returnValue() {\n      return new ast.MemberExpression(\n        new ast.Identifier('exec'),\n        new ast.Identifier('retv')\n      );\n    },\n\n    some: function (evaluation, tests) {\n      return this.callWith('__some', [evaluation].concat(tests));\n    },\n\n    toBool: function (ast) {\n      return this.callWith('__bool', ast);\n    },\n\n    get trueLiteral() {\n      return ast.Literal.for(true);\n    }\n\n  };\n});\n\n",
    "\ndefine('context',['symbols', 'ast', 'templates'], function (symbols, ast, t) {\n  'use strict';\n\n  function Context(ctx) {\n    this._processes = Object.create(null);\n    this._auxNames = Object.create(null);\n    this._currentProcessPrivates = Object.create(null);\n\n    for (var key in ctx) {\n      if (ctx.hasOwnProperty(key)) {\n        this[key] = ctx[key];\n      }\n    }\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    startLinearization: function () {\n      this._auxNames = Object.create(null);\n      this._currentLinearization = new Linearization();\n    },\n\n    getLinearizationCases: function () {\n      return this._currentLinearization.getCases();\n    },\n\n    end: function () {\n      return this._currentLinearization.end();\n    },\n\n    callFunction: function (resumeLabel, name, argList) {\n      return this._currentLinearization\n        .callFunction(resumeLabel, name, argList);\n    },\n\n    newProcess: function (resumeLabel, name, argList) {\n      return this._currentLinearization\n        .newProcess(resumeLabel, name, argList);\n    },\n\n    clone: function (childLabel, parentLabel) {\n      return this._currentLinearization.clone(childLabel, parentLabel);\n    },\n\n    frame: function (resumeLabel, expression) {\n      return this._currentLinearization.frame(resumeLabel, expression);\n    },\n\n    debug: function (resumeLabel) {\n      return this._currentLinearization.debug(resumeLabel);\n    },\n\n    declareProcess: function (name) {\n      this._processes[name] = true;\n    },\n\n    isProcess: function (name) {\n      return name in this._processes;\n    },\n\n    return: function (expression) {\n      return this._currentLinearization.return(expression);\n    },\n\n    newAux: function (name, initializer) {\n      var nameCount = this._auxNames[name] || 0;\n      var suffix = this._auxNames[name] = nameCount + 1;\n      if (nameCount > 0) {\n        name += suffix;\n      }\n      var identifier = new ast.Identifier(name);\n      var declaration = new ast.VariableDeclaration(\n        new ast.VariableDeclarator(identifier, initializer)\n      );\n      return {\n        identifier: identifier,\n        declaration: declaration\n      };\n    },\n\n    newLabel: function () {\n      return this._currentLinearization.newLabel();\n    },\n\n    label: function (label) {\n      return this._currentLinearization.label(label);\n    },\n\n    verbatim: function (ast) {\n      return this._currentLinearization.verbatim(ast);\n    },\n\n    goToIf: function (testAst, labelIfTrue, labelIfFalse) {\n      return this._currentLinearization\n        .goToIf(testAst, labelIfTrue, labelIfFalse);\n    },\n\n    goTo: function (label) {\n      return this._currentLinearization.goTo(label);\n    },\n\n    select: function (evaluation, options, defaultLabel) {\n      return this._currentLinearization.select(\n        evaluation,\n        options,\n        defaultLabel\n      );\n    },\n\n    getScope: function (identifier) {\n      var scope;\n      if (symbols.isGlobal(identifier)) {\n        scope = 'global';\n      }\n      //TODO: What about id? it is not a local but a special keyword with\n      //identifier semantics to avoid assignation on it. Should be translated\n      //as a local but identified like a special token and translated in a\n      //special way.\n      else if (symbols.isLocal(identifier)) {\n        scope = 'local';\n      }\n      else if (identifier in this._currentProcessPrivates) {\n        scope = 'private';\n      }\n      return scope;\n    },\n\n    getGlobalBaseDeclarator: function () {\n      return new ast.VariableDeclarator(\n        t.globalBaseIdentifier,\n        // TODO: Must take into account all DIV padding including program source\n        ast.Literal['for'](0)\n      );\n    }\n  };\n\n  function Linearization() {\n    this._pc = -1;\n    this._sentences = [];\n  }\n\n  Linearization.prototype = {\n    constructor: Linearization,\n\n    getCases: function () {\n      var cases = [];\n      var sentences = this._sentences;\n      var currentCase = null;\n      var caseIsFinished = false;\n      var isReturn, isLabel, consequent;\n\n      for (var i = 0, wrapper; (wrapper = sentences[i]); i++) {\n        isLabel = wrapper instanceof Label;\n        isReturn = wrapper.type === 'Return';\n\n        if (caseIsFinished && !isLabel) { continue; }\n\n        if (isLabel) {\n          currentCase = t.concurrentLabel(wrapper.label + 1);\n          cases.push(currentCase);\n        }\n        consequent = currentCase.consequent;\n        consequent.push.apply(consequent, wrapper.sentences);\n\n        caseIsFinished = isReturn || (caseIsFinished && !isLabel);\n      }\n      return cases;\n    },\n\n    newLabel: function () {\n      return new Label();\n    },\n\n    label: function (label) {\n      var lastSentence = this._sentences[this._sentences.length - 1];\n      if (lastSentence instanceof Label) {\n        label.proxy(lastSentence);\n      }\n      else {\n        label.label = this._pc + 1;\n        this._sentences.push(label);\n      }\n    },\n\n    verbatim: function (sentence) {\n      this._addSentence(this._verbatim(sentence));\n    },\n\n    goToIf: function (testAst, labelIfTrue, labelIfFalse) {\n      this._addSentence(this._goToIf(testAst, labelIfTrue, labelIfFalse));\n    },\n\n    goTo: function (label) {\n      this._addSentence(this._goTo(label));\n    },\n\n    select: function (evaluation, options, defaultLabel) {\n      this._addSentence(this._select(evaluation, options, defaultLabel));\n    },\n\n    end: function () {\n      this._addSentence(this._end());\n    },\n\n    callFunction: function (resumeLabel, name, argList) {\n      this._addSentence(this._call('function', resumeLabel, name, argList));\n    },\n\n    newProcess: function (resumeLabel, name, argList) {\n      this._addSentence(this._call('process', resumeLabel, name, argList));\n    },\n\n    clone: function (childLabel, parentLabel) {\n      this._addSentence(this._clone(childLabel, parentLabel));\n    },\n\n    frame: function (resumeLabel, expression) {\n      this._addSentence(this._frame(resumeLabel, expression));\n    },\n\n    debug: function (resumeLabel) {\n      this._addSentence(this._debug(resumeLabel));\n    },\n\n    return: function (expression) {\n      this._addSentence(this._return(expression));\n    },\n\n    _verbatim: function (sentence) {\n      return {\n        type: 'Verbatim',\n        sentences: [sentence]\n      };\n    },\n\n    _goToIf: function (testAst, labelIfTrue, labelIfFalse) {\n      var _this = this;\n      return {\n        type: 'GoToIf',\n        get sentences() {\n          return [_this._programCounterBranch(\n            testAst,\n            labelIfTrue.label,\n            labelIfFalse.label\n          ), new ast.BreakStatement()];\n        }\n      };\n    },\n\n    _goTo: function (label) {\n      var _this = this;\n      return {\n        type: 'GoTo',\n        get sentences() {\n          return [\n            _this._programCounterSet(label.label),\n            new ast.BreakStatement()\n          ];\n        }\n      };\n    },\n\n    _select: function (evaluation, options, defaultLabel) {\n      var _this = this;\n      return {\n        type: 'Select',\n        get sentences() {\n          var defaultExpression = _this._programCounterSet(defaultLabel.label);\n          var cases = options.map(function (option) {\n            var tests = option.tests;\n            return _this._programCounterBranch(\n              t.some(evaluation, tests),\n              option.label.label\n            );\n          });\n          return [defaultExpression]\n            .concat(cases)\n            .concat([new ast.BreakStatement()]);\n        }\n      };\n    },\n\n    _end: function () {\n      return {\n        type: 'End',\n        get sentences() {\n          return [t.processEnd];\n        }\n      };\n    },\n\n    _call: function (kind, resumeLabel, name, argList) {\n      var type = { 'function': 'CallFunction', 'process': 'NewProcess' }[kind];\n      return {\n        type: type,\n        get sentences() {\n          return [t.call(kind, resumeLabel.label + 1, name, argList)];\n        }\n      };\n    },\n\n    _clone: function (childLabel, parentLabel) {\n      return {\n        type: 'Clone',\n        get sentences() {\n          return [t.processClone(childLabel.label + 1, parentLabel.label + 1)];\n        }\n      };\n    },\n\n    _frame: function (resumeLabel, expression) {\n      return {\n        type: 'Frame',\n        get sentences() {\n          return [t.processFrame(resumeLabel.label + 1, expression)];\n        }\n      };\n    },\n\n    _debug: function (resumeLabel) {\n      return {\n        type: 'Debug',\n        get sentences() {\n          return [t.processDebug(resumeLabel.label + 1)];\n        }\n      };\n    },\n\n    _return: function (expression) {\n      return {\n        type: 'Return',\n        get sentences() {\n          return [t.processReturn(expression)];\n        }\n      };\n    },\n\n    _programCounterBranch: function (testAst, consequent, alternate) {\n      return new ast.ExpressionStatement(\n        new ast.AssignmentExpression(\n          t.programCounter,\n          new ast.ConditionalExpression(\n            testAst,\n            new ast.Literal(consequent + 1),\n            alternate ? new ast.Literal(alternate + 1) : t.programCounter\n          )\n        )\n      );\n    },\n\n    _programCounterSet: function (label) {\n      return new ast.ExpressionStatement(\n        new ast.AssignmentExpression(\n          t.programCounter,\n          new ast.Literal(label + 1)\n        )\n      );\n    },\n\n    _addSentence: function (ast) {\n      if (!this._sentences.length) {\n        this._sentences.push(new Label(0));\n      }\n      this._sentences.push(ast);\n      this._pc += 1;\n    }\n  };\n\n  function Label(n) { this.label = n; }\n\n  Label.prototype = {\n    constructor: Label,\n\n    proxy: function (anotherLabel) {\n      this._proxifiedLabel = anotherLabel;\n      Object.defineProperty(this, 'label', { get: function () {\n        return this._proxifiedLabel.label;\n      }});\n    },\n\n    get sentences() {\n      return [];\n    }\n  };\n\n  return {\n    Context: Context,\n    Linearization: Linearization\n  };\n\n});\n\n",
    "\ndefine('div2trans',[\n  'context',\n  'ast',\n  'templates',\n  'symbols'\n], function (ctx, ast, t, symbols) {\n  'use strict';\n\n  var translators = Object.create(null);\n\n  translators.AssignmentExpression = function (divAssignment, context) {\n    return new ast.AssignmentExpression(\n      translate(divAssignment.left, context),\n      translate(divAssignment.right, context),\n\n      // XXX: This is good luck. All assignment operators are equal!\n      divAssignment.operator\n    );\n  };\n\n  translators.BinaryExpression = function (divBinary, context) {\n    return new ast.BinaryExpression(\n      translate(divBinary.left, context),\n      translate(divBinary.right, context),\n      divBinary.operator\n    );\n  };\n\n  translators.CallExpression = function (divCall, context) {\n    var parameters = new ast.ArrayExpression(\n      divCall.arguments.map(function (arg) {\n        return translate(arg, context);\n      })\n    );\n    var id = divCall.callee.name;\n    var isProcess = context.isProcess(id);\n    var afterCallLabel = context.newLabel();\n    var auxName = (isProcess ? '_pid_' : '_result_') + id;\n    var callAux = context.newAux(auxName, t.returnValue);\n    var callKind = isProcess ? 'newProcess' : 'callFunction';\n    context[callKind](afterCallLabel, id, parameters);\n    context.label(afterCallLabel);\n    context.verbatim(callAux.declaration);\n    return callAux.identifier;\n  };\n\n  translators.CloneSentence = function (divClone, context) {\n    var insideCloneLabel = context.newLabel();\n    var afterCloneLabel = context.newLabel();\n    context.clone(insideCloneLabel, afterCloneLabel);\n    context.label(insideCloneLabel);\n    translateBody(divClone, context);\n    context.label(afterCloneLabel);\n  };\n\n  translators.Unit = function (divUnit, context) {\n    var programFunction = translate(divUnit.program, context);\n    var processesFunctions = divUnit.processes.map(function (divProcess) {\n      return translate(divProcess, context);\n    });\n    var memoryMap = getMemoryMap(context);\n    return new ast.Program(\n      memoryMap\n      .concat([programFunction])\n      .concat(processesFunctions)\n    );\n  };\n\n  function getMemoryMap(context) {\n    var offset = 0;\n    var globalBase = context.getGlobalBaseDeclarator();\n    var globalOffsets = symbols.wellKnownGlobals.map(function (symbol) {\n      // TODO: In the future, this will be a property of the symbol\n      var name = symbol;\n      var global = new ast.VariableDeclarator(\n        new t.identifierForGlobal(name),\n        new ast.Literal['for'](offset)\n      );\n      offset += 4; // TODO: Extract info from the symbol\n      return global;\n    });\n    // XXX: Notice this return a list of variable declarators.\n    return [new ast.VariableDeclaration([globalBase].concat(globalOffsets))];\n  }\n\n  translators.Program = function (divProgram, context) {\n    var name = divProgram.name.name;\n    var body = translate(divProgram.body, context);\n    return t.programFunction(name, body);\n  };\n\n  translators.Process = function (divProgram, context) {\n    var name = divProgram.name.name;\n    var body = translate(divProgram.body, context);\n    return t.processFunction(name, body);\n  };\n\n  translators.ProcessBody = function (divBody, context) {\n    context.startLinearization();\n    divBody.sentences.map(function (sentence) {\n      translate(sentence, context);\n    });\n    context.end();\n    var bodyCases = context.getLinearizationCases();\n    return t.concurrentBody(bodyCases);\n  };\n\n  translators.Identifier = function (divIdentifier, context) {\n    var name = divIdentifier.name;\n    var scope = context.getScope(name);\n    if (!scope) { throw new Error('Unknown name ' + name); }\n    var scopeTranslator = 'memory' + scope[0].toUpperCase() + scope.substr(1);\n    if (!(scopeTranslator in t)) { throw new Error('Unknown scope ' + scope); }\n    return t[scopeTranslator](name);\n  };\n\n  translators.IfSentence = function (divIf, context) {\n    var consequentLabel = context.newLabel();\n    var alternateLabel = context.newLabel();\n\n    var test = t.toBool(translate(divIf.test, context));\n    context.goToIf(test, consequentLabel, alternateLabel);\n    context.label(consequentLabel);\n    translateBody(divIf, context, 'consequent');\n    context.label(alternateLabel);\n    if (divIf.alternate) {\n      translateBody(divIf, context, 'alternate');\n    }\n  };\n\n  translators.ExpressionSentence = function (divExpression, context) {\n    var expression = translate(divExpression.expression, context);\n    context.verbatim(new ast.ExpressionStatement(expression));\n  };\n\n  translators.Literal = function (divLiteral) {\n    return ast.Literal.for(divLiteral.value);\n  };\n\n  translators.WhileSentence = function (divWhile, context) {\n    var loopStartLabel = context.newLabel();\n    var afterLoopLabel = context.newLabel();\n    var testLabel = context.newLabel();\n\n    context.label(testLabel);\n    context.goToIf(\n      translate(divWhile.test, context),\n      loopStartLabel,\n      afterLoopLabel\n    );\n\n    context.label(loopStartLabel);\n    translateBody(divWhile, context);\n    context.goTo(testLabel);\n\n    context.label(afterLoopLabel);\n  };\n\n  translators.LoopSentence = function (divLoop, context) {\n    var loopStartLabel = context.newLabel();\n    var afterLoopLabel = context.newLabel();\n\n    context.label(loopStartLabel);\n    translateBody(divLoop, context);\n    context.goTo(loopStartLabel);\n\n    context.label(afterLoopLabel);\n  };\n\n  translators.RepeatSentence = function (divRepeat, context) {\n    var loopStartLabel = context.newLabel();\n    var afterLoopLabel = context.newLabel();\n\n    context.label(loopStartLabel);\n    translateBody(divRepeat, context);\n    context.goToIf(\n      translate(divRepeat.test, context),\n      afterLoopLabel,\n      loopStartLabel\n    );\n\n    context.label(afterLoopLabel);\n  };\n\n  translators.ReturnSentence = function (divReturn, context) {\n    var returnArgument = divReturn.argument;\n    if (!returnArgument) {\n      returnArgument = t.defaultReturnArgument;\n    }\n    context.return(translate(returnArgument, context));\n  };\n\n  translators.SwitchSentence = function (divSwitch, context) {\n    var afterSwitchLabel = context.newLabel();\n    var defaultCaseLabel = context.newLabel();\n\n    var cases = divSwitch.cases;\n    var lastCase = cases[cases.length - 1];\n    var hasDefault = lastCase && lastCase.tests === null;\n    if (hasDefault) { cases.pop(); }\n\n    var discriminant = translate(divSwitch.discriminant, context);\n    var aux = context.newAux('_switch', discriminant);\n    var choices = generateChoices(cases, context);\n\n    context.verbatim(aux.declaration);\n    context.select(\n      aux.identifier, choices,\n      hasDefault ? defaultCaseLabel : afterSwitchLabel\n    );\n    choices.forEach(function (choice) {\n      context.label(choice.label);\n      translateBody(choice.case, context, 'consequent');\n      context.goTo(afterSwitchLabel);\n    });\n    if (hasDefault) {\n      var defaultCase = lastCase;\n      context.label(defaultCaseLabel);\n      translateBody(defaultCase, context, 'consequent');\n      context.goTo(afterSwitchLabel);\n    }\n    context.label(afterSwitchLabel);\n  };\n\n  function generateChoices(cases, context) {\n    return cases.map(function (caseClause) {\n      return {\n        label: context.newLabel(),\n        tests: caseClause.tests.map(function (test) {\n          return translate(test, context);\n        }),\n        case: caseClause\n      };\n    });\n  }\n\n\n  translators.FrameSentence = function (divFrame, context) {\n    var resumeLabel = context.newLabel();\n    var argument = divFrame.argument || t.defaultFrameArgument;\n    context.frame(resumeLabel, translate(argument, context));\n    context.label(resumeLabel);\n  };\n\n  translators.DebugSentence = function (divDebug, context) {\n    var resumeLabel = context.newLabel();\n    context.debug(resumeLabel);\n    context.label(resumeLabel);\n  };\n\n  translators.FromSentence = function (divFrom, context) {\n    var initValue = divFrom.init.value;\n    var limitValue = divFrom.limit.value;\n    var isAscendant = initValue < limitValue;\n    var defaultStep = isAscendant ? 1 : -1;\n    var step = divFrom.step ? divFrom.step.value : defaultStep;\n    var identifier = divFrom.identifier.name;\n\n    var init = t.fromInitilizator(identifier, initValue);\n    var test = t.fromTest(identifier, limitValue, isAscendant);\n    var update = t.fromIncrement(identifier, step);\n\n    translateForLikeLoop(divFrom, [init], [test], [update], context);\n  };\n\n  translators.ForSentence = function (divFor, context) {\n    var inits = divFor.inits;\n    var tests = divFor.tests;\n    var updates = divFor.updates;\n    translateForLikeLoop(divFor, inits, tests, updates, context);\n  };\n\n  translators.Range = function (divRange) {\n    return t.newRange(divRange.min, divRange.max);\n  };\n\n  /**\n   * All parameters here must be DIV2 AST.\n   */\n  function translateForLikeLoop(loop, inits, tests, updates, context) {\n    var test = t.every(tests.map(function (test) {\n      return t.toBool(translate(test, context));\n    }));\n\n    var testLabel = context.newLabel();\n    var loopStartLabel = context.newLabel();\n    var afterLoopLabel = context.newLabel();\n    var updatesLabel = context.newLabel();\n\n    inits.forEach(verbatim);\n\n    context.label(testLabel);\n    if (test) {\n      context.goToIf(test, loopStartLabel, afterLoopLabel);\n    }\n\n    context.label(loopStartLabel);\n    translateBody(loop, context);\n\n    context.label(updatesLabel);\n    updates.forEach(verbatim);\n    context.goTo(testLabel);\n\n    context.label(afterLoopLabel);\n\n    function verbatim(divExpression) {\n      context.verbatim(new ast.ExpressionStatement(\n        translate(divExpression, context)\n      ));\n    }\n  }\n\n  function translate(divAst, context) {\n    if (!divAst || !divAst.type) { throw new Error('Invalid DIV2 AST'); }\n    if (!(divAst.type in translators)) {\n      throw new Error('Translation unavailable for ' + divAst.type + ' AST');\n    }\n    return translators[divAst.type](divAst, context);\n  }\n\n  function translateBody(divBodySentence, context, bodyProperty) {\n    bodyProperty = bodyProperty || 'body';\n    return divBodySentence[bodyProperty].sentences.map(function (sentence) {\n      return translate(sentence, context);\n    });\n  }\n\n  return {\n    translate: translate\n  };\n});\n\n",
    "\ndefine('div2js',[\n  'div2lang',\n  'div2trans'\n], function (parser, translator) {\n  'use strict';\n\n  parser.yy = parser.yy || {};\n  parser.yy.parseError = parser.parseError;\n\n  return {\n    parser: parser,\n    translator: translator\n  };\n\n});\n\n"
  ]
}